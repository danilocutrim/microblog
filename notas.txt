app / models.py : Novos campos no modelo do usuário

class User(UserMixin, db.Model):
    # ...
    about_me = db.Column(db.String(140))
    last_seen = db.Column(db.DateTime, default=datetime.utcnow)
Toda vez que o banco de dados é modificado, é necessário gerar uma migração do banco de dados. No Capítulo 4 , mostrei como configurar o aplicativo para rastrear mudanças no banco de dados por meio de scripts de migração. Agora tenho dois novos campos que desejo adicionar ao banco de dados, portanto, a primeira etapa é gerar o script de migração:

(venv) $ flask db migrate -m "new fields in user model"
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
INFO  [alembic.autogenerate.compare] Detected added column 'user.about_me'
INFO  [alembic.autogenerate.compare] Detected added column 'user.last_seen'
  Generating /home/miguel/microblog/migrations/versions/37f06a334dbf_new_fields_in_user_model.py ... done
A saída do migratecomando parece boa, pois mostra que os dois novos campos da Userclasse foram detectados. Agora posso aplicar essa alteração ao banco de dados:

(venv) $ flask db upgrade
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
INFO  [alembic.runtime.migration] Running upgrade 780739b227a7 -> 37f06a334dbf, new fields in user model

Gravando o último horário de visita para um usuário
Vamos começar com o last_seencampo, que é o mais fácil dos dois. O que eu quero fazer é escrever a hora atual nesse campo para um determinado usuário sempre que o usuário enviar uma solicitação ao servidor.

Adicionar o login para definir este campo em todas as funções possíveis de visualização que podem ser solicitadas pelo navegador é obviamente impraticável, mas executar um pouco de lógica genérica antes de uma solicitação ser enviada para uma função de visualização é uma tarefa tão comum em aplicativos da Web que o Flask oferece como um recurso nativo. Dê uma olhada na solução:

app / routes.py : hora da última visita

from datetime import datetime

@app.before_request
def before_request():
    if current_user.is_authenticated:
        current_user.last_seen = datetime.utcnow()
        db.session.commit()
O @before_requestdecorador do Flask registra a função decorada para ser executada logo antes da função view. Isso é extremamente útil porque agora posso inserir o código que desejo executar antes de qualquer função de visualização no aplicativo, e posso tê-lo em um único local. A implementação simplesmente verifica se a conta current_userestá conectada e, nesse caso, define o last_seencampo para a hora atual. Eu mencionei isso antes, um aplicativo de servidor precisa trabalhar em unidades de tempo consistentes e a prática padrão é usar o fuso horário UTC. Usar a hora local do sistema não é uma boa ideia, porque o que está no banco de dados depende da sua localização. A última etapa é confirmar a sessão do banco de dados, para que a alteração feita acima seja gravada no banco de dados. Se você está se perguntando por que não hádb.session.add()antes do commit, considere que, quando você fizer referência current_user, o Flask-Login chamará a função de retorno de chamada do loader do usuário, que executará uma consulta ao banco de dados que colocará o usuário de destino na sessão do banco de dados. Então você pode adicionar o usuário novamente nesta função, mas não é necessário porque já está lá.